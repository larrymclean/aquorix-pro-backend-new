/**
 * ============================================================================
 * AQUORIX API - /api/v1/me (Identity + Operator Context)
 * ============================================================================
 * File:        src/routes/me.js
 * Purpose:     Single source of truth for authenticated user identity, operator
 *              context, onboarding status, and permission flags (Phase C keystone).
 * Version:     v1.0.2
 * Created:     2025-12-23
 * Updated:     2025-12-25
 * Author:      Larry McLean
 * Project:     AQUORIX™ API Project
 *
 * Description:
 * - Returns authenticated user context used for frontend routing and guards.
 * - Requires JWT auth (Supabase) and resolves operator context via affiliations.
 * - DB-backed: pulls canonical user + onboarding_metadata from aquorix DB.
 *
 * Dependencies:
 * - middleware/auth.js (requireAuth)
 * - middleware/resolveOperator.js (resolveOperator)
 * - req.auth (from requireAuth)
 * - req.operatorContext (from resolveOperator)
 * - req.app.locals.pool (Postgres pool)
 *
 * Change Log:
 * -----------
 * v1.0.0 - 2025-12-23 - Larry McLean
 *   - Initial creation of GET /api/v1/me endpoint
 * v1.0.1 - 2025-12-24 - Larry McLean
 *   - DB-backed /me: joins aquorix.users + aquorix.pro_profiles
 *   - Returns onboarding_metadata and stable routing_hint
 *   - Removes ambiguous export/import “support both” patterns
 * v1.0.2 - 2025-12-25 - Larry McLean
 *   - Self-heal: create aquorix.users + aquorix.pro_profiles on first /me for new Supabase signups
 *   - Satisfy NOT NULL fields (email, username, tier_level) deterministically
 *   - Re-run canonical query to preserve response shape (no payload drift)
 *
 * Notes:
 * - Do NOT alter existing changelog entries
 * - Always append new changes with version bump
 * - Follow semantic versioning: MAJOR.MINOR.PATCH
 * ============================================================================
 */

const express = require("express");
const router = express.Router();

const requireAuth = require("../middleware/auth");
const resolveOperator = require("../middleware/resolveOperator");

// Fail fast if middleware wiring breaks (prevents silent drift)
if (typeof requireAuth !== "function") {
  throw new Error("Middleware load error: requireAuth is not a function.");
}
if (typeof resolveOperator !== "function") {
  throw new Error("Middleware load error: resolveOperator is not a function.");
}

/**
 * GET /api/v1/me
 * Requires: Authorization: Bearer <Supabase JWT>
 */
router.get("/", requireAuth, resolveOperator, async (req, res) => {
  try {
    const pool = req.app?.locals?.pool;
    if (!pool) {
      return res.status(500).json({ ok: false, error: "DB_POOL_MISSING" });
    }

    // ✅ Read auth context from req.auth (set by requireAuth)
    const supabase_user_id = req.auth?.supabase_user_id || null;
    const email_from_jwt = req.auth?.email || null;

    if (!supabase_user_id) {
      return res.status(401).json({
        ok: false,
        error: "AUTH_CONTEXT_MISSING",
        message: "JWT verified but supabase_user_id not found on req.auth",
      });
    }

    // ✅ Read operator context from req.operatorContext (set by resolveOperator)
    const operatorCtx = req.operatorContext || {};
    const operator_id = operatorCtx.operator_id ?? null;
    const affiliation = operatorCtx.affiliation_type ?? null;

    // Canonical user + profile (DB truth)
    const userQ = `
      SELECT
        u.user_id,
        u.supabase_user_id,
        u.email,
        u.tier,
        u.role,
        u.created_at,
        p.first_name,
        p.last_name,
        p.phone,
        p.onboarding_metadata
      FROM aquorix.users u
      LEFT JOIN aquorix.pro_profiles p ON p.user_id = u.user_id
      WHERE u.supabase_user_id = $1
      LIMIT 1;
    `;

    // IMPORTANT: must be 'let' because Phase B self-heal re-runs this query
    let userR = await pool.query(userQ, [supabase_user_id]);

    // ------------------------------------------------------------------------
    // Phase B Self-Heal (v1.0.2): First /me call after Supabase signup
    // Creates required aquorix.users + aquorix.pro_profiles rows (idempotent)
    // Requirements based on schema:
    // - aquorix.users.email NOT NULL
    // - aquorix.users.username NOT NULL (UNIQUE)
    // - aquorix.pro_profiles.tier_level NOT NULL (1..5)
    // ------------------------------------------------------------------------
    if (userR.rows.length === 0) {
      if (!email_from_jwt) {
        // Cannot satisfy users.email NOT NULL without email. Fail fast.
        return res.status(400).json({
          ok: false,
          error: "AUTH_EMAIL_MISSING",
          message:
            "JWT verified but email not found on req.auth; cannot self-heal users row.",
          identity: { supabase_user_id, email: null },
          routing_hint: "onboarding",
        });
      }

      const client = await pool.connect();
      try {
        await client.query("BEGIN");

        // Deterministic username generation (<= 50 chars), avoids collisions using UUID suffix
        const emailLocal = String(email_from_jwt).split("@")[0] || "user";
        const safeBase = emailLocal
          .toLowerCase()
          .replace(/[^a-z0-9_]/g, "_")
          .replace(/_+/g, "_")
          .replace(/^_+|_+$/g, "");

        const uuidSuffix = String(supabase_user_id).replace(/-/g, "").slice(0, 8);
        const base = safeBase || "user";

        const u1 = `${base}_${uuidSuffix}`.slice(0, 50);
        const uuidSuffix2 = String(supabase_user_id).replace(/-/g, "").slice(0, 12);
        const u2 = `user_${uuidSuffix2}`.slice(0, 50);

        const userUpsertQ =  `
          INSERT INTO aquorix.users (supabase_user_id, email, username, tier, role, created_at)
          VALUES ($1, $2, $3, 'solo', 'user', NOW())
          ON CONFLICT (supabase_user_id)
          DO UPDATE SET email = EXCLUDED.email
          RETURNING user_id;
        `;

        // Attempt insert with u1; on username collision, retry u2.
        // NOTE: if email is already taken by some other record, Postgres will throw 23505 and we fail out (correct).
        let user_id;

        try {
          const up1 = await client.query(userUpsertQ, [supabase_user_id, email_from_jwt, u1]);
          user_id = up1.rows[0]?.user_id;
        } catch (e) {
          if (e && e.code === "23505") {
            const up2 = await client.query(userUpsertQ, [supabase_user_id, email_from_jwt, u2]);
            user_id = up2.rows[0]?.user_id;
          } else {
            throw e;
          }
        }

        if (!user_id) {
          throw new Error("SELF_HEAL_FAILED_NO_USER_ID");
        }

        // Ensure pro_profiles exists (tier_level NOT NULL) + init onboarding_metadata
        const initOnboarding = {
          started_at: new Date().toISOString(),
          current_step: 1,
          last_activity: new Date().toISOString(),
          completed_steps: [],
          completion_percentage: 0,
        };

        await client.query(
          `
          INSERT INTO aquorix.pro_profiles (user_id, tier_level, onboarding_metadata)
          VALUES ($1, $2, $3::jsonb)
          ON CONFLICT (user_id) DO NOTHING;
          `,
          [user_id, 1, JSON.stringify(initOnboarding)]
        );

        await client.query("COMMIT");
      } catch (err) {
        try {
          await client.query("ROLLBACK");
        } catch (rbErr) {
          console.error("[/api/v1/me] self-heal rollback failed:", rbErr);
        }

        console.error("[/api/v1/me] self-heal failed:", err);
        return res.status(500).json({
          ok: false,
          error: "SELF_HEAL_FAILED",
          message: err?.message || "Self-heal failed",
          identity: { supabase_user_id, email: email_from_jwt },
          routing_hint: "onboarding",
        });
      } finally {
        client.release();
      }

      // Re-run canonical query to preserve response shape
      userR = await pool.query(userQ, [supabase_user_id]);

      if (!userR.rows || userR.rows.length === 0) {
        return res.status(500).json({
          ok: false,
          error: "SELF_HEAL_POST_QUERY_FAILED",
          message: "Self-heal completed but canonical user query returned no rows.",
          identity: { supabase_user_id, email: email_from_jwt },
          routing_hint: "onboarding",
        });
      }
    }

    const dbUser = userR.rows[0];

    // Operator details (optional if operator_id missing)
    let operatorRow = null;
    if (operator_id) {
      const opQ = `
        SELECT operator_id, name, COALESCE(timezone, 'UTC') AS timezone
        FROM aquorix.diveoperators
        WHERE operator_id = $1
        LIMIT 1;
      `;
      const opR = await pool.query(opQ, [operator_id]);
      operatorRow = opR.rows[0] || null;
    }

    // Onboarding status
    const om = dbUser.onboarding_metadata || {};
    const current_step = om.current_step ?? null;
    const completed_steps = Array.isArray(om.completed_steps) ? om.completed_steps : [];
    const completion_percentage =
      typeof om.completion_percentage === "number" ? om.completion_percentage : null;

    // STRICT completion rule (Phase B+):
    // Dashboard ONLY when explicitly sealed.
    // - completion_percentage === 100 OR om.is_complete === true
    // Everything else is onboarding.
    const is_complete =
      om.is_complete === true ||
      completion_percentage === 100;

    const routing_hint = is_complete ? "dashboard" : "onboarding";

    const permissions = {
      can_view_schedule: true,
      can_edit_profile: true,
      can_manage_operator: affiliation === "owner" || affiliation === "admin",
    };

    return res.json({
      ok: true,
      authenticated: true,

      identity: {
        supabase_user_id,
        email: dbUser.email || email_from_jwt,
      },

      aquorix_user: {
        user_id: dbUser.user_id,
        tier: dbUser.tier || null,
        role: dbUser.role || "user",
        created_at: dbUser.created_at || null,
        profile: {
          first_name: dbUser.first_name || null,
          last_name: dbUser.last_name || null,
          phone: dbUser.phone || null,
        },
      },

      operator: {
        operator_id: operator_id || null,
        name: operatorRow?.name || null,
        timezone: operatorRow?.timezone || null,
        affiliation,
      },

      onboarding: {
        current_step,
        completed_steps,
        completion_percentage,
        is_complete,
      },

      routing_hint,
      permissions,
      server_time_utc: new Date().toISOString(),
    });
  } catch (err) {
    console.error("[/api/v1/me] failed:", err);
    return res.status(500).json({
      ok: false,
      error: "ME_ENDPOINT_FAILED",
      message: err?.message || "Unknown error",
    });
  }
});

module.exports = router;